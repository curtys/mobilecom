//
// Generated file, do not edit! Created by opp_msgc 4.1 from hip/HipMessages.msg.
//

#ifndef _HIPMESSAGES_M_H_
#define _HIPMESSAGES_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "IPv6Address.h"
#include "IPv6Datagram.h"
#include "IPv6ExtensionHeaders_m.h"
// }}

// cplusplus {{
const int IPPROTO_NONE = 59;

const int HIP_MAX_HEADER_BYTES = 2008;

typedef cMessage *cMessagePtr;
typedef IPv6EncapsulatingSecurityPayloadHeader *IPv6EncapsulatingSecurityPayloadHeaderPtr;
// }}



/**
 * Enum generated from <tt>hip/HipMessages.msg</tt> by opp_msgc.
 * <pre>
 * enum HipPacketType
 * {
 * 
 *     I1 = 1;
 *     R1 = 2;
 *     I2 = 3;
 *     R2 = 4;
 *     UPDATE = 16;
 *     NOTIFY = 17;
 *     CLOSE = 18;
 *     CLOSE_ACK = 19;
 *     ESP_DATA = 666;
 *     UPDATE_SEQ = 20;
 *     UPDATE_ACK = 21;
 * }
 * </pre>
 */
enum HipPacketType {
    I1 = 1,
    R1 = 2,
    I2 = 3,
    R2 = 4,
    UPDATE = 16,
    NOTIFY = 17,
    CLOSE = 18,
    CLOSE_ACK = 19,
    ESP_DATA = 666,
    UPDATE_SEQ = 20,
    UPDATE_ACK = 21
};

/**
 * Struct generated from hip/HipMessages.msg by opp_msgc.
 */
struct HipLocator
{
    HipLocator();
    int type;
    int length;
    short trafficType;
    short locatorType;
    int locatorLength;
    short reserved;
    short p;
    int locatorLifetime;
    ::IPv6Address locatorIPv6addr;
    int locatorESP_SPI;
};

void doPacking(cCommBuffer *b, HipLocator& a);
void doUnpacking(cCommBuffer *b, HipLocator& a);

/**
 * Class generated from <tt>hip/HipMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet HIPHeaderMessage
 * {
 *     
 *     int nextHeader = IPPROTO_NONE;
 *     
 *     int length = 4;
 *     int packetType enum(HipPacketType);
 *     
 *     short version = 1;
 *     
 *     IPv6Address srcHIT;
 *     IPv6Address destHIT;
 *     
 *     short reg_info = 0;
 *     short reg_req = 0;
 *     short reg_res = 0;
 *     IPv6Address from_i;
 *     int rvs_mac;
 *     IPv6Address via_rvs;
 * 
 *     
 *     HipLocator locator[];
 *     unsigned int r1_counter;
 *     int puzzle;
 *     int soution;
 *     int seq;
 *     int ack;
 *     int diffie_hellman;
 *     int hip_transform;
 *     int encrypted;
 *     int host_id;
 *     int cert;
 *     int notification;
 *     int echo_request_signed;
 *     int echo_response_signed;
 *     int hmac;
 *     int hmac_2;
 *     int hip_signature;
 *     int echo_request_unsigned;
 *     int echo_response_unsigned;
 * }
 * </pre>
 */
class HIPHeaderMessage : public ::cPacket
{
  protected:
    int nextHeader_var;
    int length_var;
    int packetType_var;
    short version_var;
    ::IPv6Address srcHIT_var;
    ::IPv6Address destHIT_var;
    short reg_info_var;
    short reg_req_var;
    short reg_res_var;
    ::IPv6Address from_i_var;
    int rvs_mac_var;
    ::IPv6Address via_rvs_var;
    ::HipLocator *locator_var; // array ptr
    unsigned int locator_arraysize;
    unsigned int r1_counter_var;
    int puzzle_var;
    int soution_var;
    int seq_var;
    int ack_var;
    int diffie_hellman_var;
    int hip_transform_var;
    int encrypted_var;
    int host_id_var;
    int cert_var;
    int notification_var;
    int echo_request_signed_var;
    int echo_response_signed_var;
    int hmac_var;
    int hmac_2_var;
    int hip_signature_var;
    int echo_request_unsigned_var;
    int echo_response_unsigned_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HIPHeaderMessage&);

  public:
    HIPHeaderMessage(const char *name=NULL, int kind=0);
    HIPHeaderMessage(const HIPHeaderMessage& other);
    virtual ~HIPHeaderMessage();
    HIPHeaderMessage& operator=(const HIPHeaderMessage& other);
    virtual HIPHeaderMessage *dup() const {return new HIPHeaderMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getNextHeader() const;
    virtual void setNextHeader(int nextHeader_var);
    virtual int getLength() const;
    virtual void setLength(int length_var);
    virtual int getPacketType() const;
    virtual void setPacketType(int packetType_var);
    virtual short getVersion() const;
    virtual void setVersion(short version_var);
    virtual IPv6Address& getSrcHIT();
    virtual const IPv6Address& getSrcHIT() const {return const_cast<HIPHeaderMessage*>(this)->getSrcHIT();}
    virtual void setSrcHIT(const IPv6Address& srcHIT_var);
    virtual IPv6Address& getDestHIT();
    virtual const IPv6Address& getDestHIT() const {return const_cast<HIPHeaderMessage*>(this)->getDestHIT();}
    virtual void setDestHIT(const IPv6Address& destHIT_var);
    virtual short getReg_info() const;
    virtual void setReg_info(short reg_info_var);
    virtual short getReg_req() const;
    virtual void setReg_req(short reg_req_var);
    virtual short getReg_res() const;
    virtual void setReg_res(short reg_res_var);
    virtual IPv6Address& getFrom_i();
    virtual const IPv6Address& getFrom_i() const {return const_cast<HIPHeaderMessage*>(this)->getFrom_i();}
    virtual void setFrom_i(const IPv6Address& from_i_var);
    virtual int getRvs_mac() const;
    virtual void setRvs_mac(int rvs_mac_var);
    virtual IPv6Address& getVia_rvs();
    virtual const IPv6Address& getVia_rvs() const {return const_cast<HIPHeaderMessage*>(this)->getVia_rvs();}
    virtual void setVia_rvs(const IPv6Address& via_rvs_var);
    virtual void setLocatorArraySize(unsigned int size);
    virtual unsigned int getLocatorArraySize() const;
    virtual HipLocator& getLocator(unsigned int k);
    virtual const HipLocator& getLocator(unsigned int k) const {return const_cast<HIPHeaderMessage*>(this)->getLocator(k);}
    virtual void setLocator(unsigned int k, const HipLocator& locator_var);
    virtual unsigned int getR1_counter() const;
    virtual void setR1_counter(unsigned int r1_counter_var);
    virtual int getPuzzle() const;
    virtual void setPuzzle(int puzzle_var);
    virtual int getSoution() const;
    virtual void setSoution(int soution_var);
    virtual int getSeq() const;
    virtual void setSeq(int seq_var);
    virtual int getAck() const;
    virtual void setAck(int ack_var);
    virtual int getDiffie_hellman() const;
    virtual void setDiffie_hellman(int diffie_hellman_var);
    virtual int getHip_transform() const;
    virtual void setHip_transform(int hip_transform_var);
    virtual int getEncrypted() const;
    virtual void setEncrypted(int encrypted_var);
    virtual int getHost_id() const;
    virtual void setHost_id(int host_id_var);
    virtual int getCert() const;
    virtual void setCert(int cert_var);
    virtual int getNotification() const;
    virtual void setNotification(int notification_var);
    virtual int getEcho_request_signed() const;
    virtual void setEcho_request_signed(int echo_request_signed_var);
    virtual int getEcho_response_signed() const;
    virtual void setEcho_response_signed(int echo_response_signed_var);
    virtual int getHmac() const;
    virtual void setHmac(int hmac_var);
    virtual int getHmac_2() const;
    virtual void setHmac_2(int hmac_2_var);
    virtual int getHip_signature() const;
    virtual void setHip_signature(int hip_signature_var);
    virtual int getEcho_request_unsigned() const;
    virtual void setEcho_request_unsigned(int echo_request_unsigned_var);
    virtual int getEcho_response_unsigned() const;
    virtual void setEcho_response_unsigned(int echo_response_unsigned_var);
};

inline void doPacking(cCommBuffer *b, HIPHeaderMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HIPHeaderMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>hip/HipMessages.msg</tt> by opp_msgc.
 * <pre>
 * packet ESPMessage
 * {
 *     IPv6EncapsulatingSecurityPayloadHeaderPtr esp;
 * }
 * </pre>
 */
class ESPMessage : public ::cPacket
{
  protected:
    ::IPv6EncapsulatingSecurityPayloadHeaderPtr esp_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ESPMessage&);

  public:
    ESPMessage(const char *name=NULL, int kind=0);
    ESPMessage(const ESPMessage& other);
    virtual ~ESPMessage();
    ESPMessage& operator=(const ESPMessage& other);
    virtual ESPMessage *dup() const {return new ESPMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv6EncapsulatingSecurityPayloadHeaderPtr& getEsp();
    virtual const IPv6EncapsulatingSecurityPayloadHeaderPtr& getEsp() const {return const_cast<ESPMessage*>(this)->getEsp();}
    virtual void setEsp(const IPv6EncapsulatingSecurityPayloadHeaderPtr& esp_var);
};

inline void doPacking(cCommBuffer *b, ESPMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ESPMessage& obj) {obj.parsimUnpack(b);}


#endif // _HIPMESSAGES_M_H_
