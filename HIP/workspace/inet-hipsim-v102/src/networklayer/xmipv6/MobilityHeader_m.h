//
// Generated file, do not edit! Created by opp_msgc 4.1 from networklayer/xmipv6/MobilityHeader.msg.
//

#ifndef _MOBILITYHEADER_M_H_
#define _MOBILITYHEADER_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "INETDefs.h"
#include "IPv6Address.h"
#include "IPv6Datagram.h" 
#include "IPv6ExtensionHeaders.h"
// }}



/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum MobilityHeaderType
 * {
 * 
 *     BINDING_REFRESH_REQUEST = 0;
 *     HOME_TEST_INIT = 1;
 *     CARE_OF_TEST_INIT = 2;
 *     HOME_TEST = 3;
 *     CARE_OF_TEST = 4;
 *     BINDING_UPDATE = 5;
 *     BINDING_ACKNOWLEDGEMENT = 6;
 *     BINDING_ERROR = 7;
 * }
 * </pre>
 */
enum MobilityHeaderType {
    BINDING_REFRESH_REQUEST = 0,
    HOME_TEST_INIT = 1,
    CARE_OF_TEST_INIT = 2,
    HOME_TEST = 3,
    CARE_OF_TEST = 4,
    BINDING_UPDATE = 5,
    BINDING_ACKNOWLEDGEMENT = 6,
    BINDING_ERROR = 7
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum BAStatus
 * {
 * 
 *     BINDING_UPDATE_ACCEPTED = 0;
 *     BU_ACCEPT_BUT_DISCOVER_PREFIX = 1;
 *     REASON_UNSPECIFIED = 128;
 *     ADMINISTRATIVELY_PROHIBITED = 129;
 *     INSUFFICIENT_RESOURCES = 130;
 *     HOME_REGISTRATION_NOT_SUPPORTED = 131;
 *     NOT_HOME_SUBNET = 132;
 *     NOT_HA_FOR_THIS_MN = 133;
 *     DAD_FAILED = 134;
 *     SEQUENCE_NUMBER_OUT_OF_WINDOW = 135;
 *     EXPIRED_HOME_NONCE_INDEX = 136;
 *     EXPIRED_CARE_OF_NONCE_INDEX = 137;
 *     EXPIRED_NONCES = 138;
 *     REGISTRATION_TYPE_CHANGE_DISALLOWED = 139;
 * }
 * </pre>
 */
enum BAStatus {
    BINDING_UPDATE_ACCEPTED = 0,
    BU_ACCEPT_BUT_DISCOVER_PREFIX = 1,
    REASON_UNSPECIFIED = 128,
    ADMINISTRATIVELY_PROHIBITED = 129,
    INSUFFICIENT_RESOURCES = 130,
    HOME_REGISTRATION_NOT_SUPPORTED = 131,
    NOT_HOME_SUBNET = 132,
    NOT_HA_FOR_THIS_MN = 133,
    DAD_FAILED = 134,
    SEQUENCE_NUMBER_OUT_OF_WINDOW = 135,
    EXPIRED_HOME_NONCE_INDEX = 136,
    EXPIRED_CARE_OF_NONCE_INDEX = 137,
    EXPIRED_NONCES = 138,
    REGISTRATION_TYPE_CHANGE_DISALLOWED = 139
};

/**
 * Enum generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * enum BEStatus
 * {
 * 
 *     UNKNOWN_BINDING_FOR_HOME_ADDRESS_DEST_OPTION = 1;
 *     UNKNOWN_MH_TYPE = 2; 
 * }
 * </pre>
 */
enum BEStatus {
    UNKNOWN_BINDING_FOR_HOME_ADDRESS_DEST_OPTION = 1,
    UNKNOWN_MH_TYPE = 2
};

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet MobilityHeader 
 * {
 *     int mobilityHeaderType enum(MobilityHeaderType);
 * }
 * </pre>
 */
class MobilityHeader : public ::cPacket
{
  protected:
    int mobilityHeaderType_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MobilityHeader&);

  public:
    MobilityHeader(const char *name=NULL, int kind=0);
    MobilityHeader(const MobilityHeader& other);
    virtual ~MobilityHeader();
    MobilityHeader& operator=(const MobilityHeader& other);
    virtual MobilityHeader *dup() const {return new MobilityHeader(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMobilityHeaderType() const;
    virtual void setMobilityHeaderType(int mobilityHeaderType_var);
};

inline void doPacking(cCommBuffer *b, MobilityHeader& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MobilityHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingUpdate extends MobilityHeader
 * {
 *     unsigned int lifetime;
 *     unsigned int sequence;
 *     bool ackFlag;				
 *     bool homeRegistrationFlag;		
 *     bool linkLocalAddressCompatibilityFlag;	
 *     bool keyManagementFlag = false;		
 *     
 *     IPv6Address homeAddressMN;		
 * 
 *     
 *     int bindingAuthorizationData = 0; 
 * }
 * </pre>
 */
class BindingUpdate : public ::MobilityHeader
{
  protected:
    unsigned int lifetime_var;
    unsigned int sequence_var;
    bool ackFlag_var;
    bool homeRegistrationFlag_var;
    bool linkLocalAddressCompatibilityFlag_var;
    bool keyManagementFlag_var;
    ::IPv6Address homeAddressMN_var;
    int bindingAuthorizationData_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingUpdate&);

  public:
    BindingUpdate(const char *name=NULL, int kind=0);
    BindingUpdate(const BindingUpdate& other);
    virtual ~BindingUpdate();
    BindingUpdate& operator=(const BindingUpdate& other);
    virtual BindingUpdate *dup() const {return new BindingUpdate(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getLifetime() const;
    virtual void setLifetime(unsigned int lifetime_var);
    virtual unsigned int getSequence() const;
    virtual void setSequence(unsigned int sequence_var);
    virtual bool getAckFlag() const;
    virtual void setAckFlag(bool ackFlag_var);
    virtual bool getHomeRegistrationFlag() const;
    virtual void setHomeRegistrationFlag(bool homeRegistrationFlag_var);
    virtual bool getLinkLocalAddressCompatibilityFlag() const;
    virtual void setLinkLocalAddressCompatibilityFlag(bool linkLocalAddressCompatibilityFlag_var);
    virtual bool getKeyManagementFlag() const;
    virtual void setKeyManagementFlag(bool keyManagementFlag_var);
    virtual IPv6Address& getHomeAddressMN();
    virtual const IPv6Address& getHomeAddressMN() const {return const_cast<BindingUpdate*>(this)->getHomeAddressMN();}
    virtual void setHomeAddressMN(const IPv6Address& homeAddressMN_var);
    virtual int getBindingAuthorizationData() const;
    virtual void setBindingAuthorizationData(int bindingAuthorizationData_var);
};

inline void doPacking(cCommBuffer *b, BindingUpdate& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingUpdate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingAcknowledgement extends MobilityHeader
 * {
 *     int status enum(BAStatus);
 *     unsigned int sequenceNumber;
 *     unsigned int lifetime;
 *     bool keyManagementFlag = false;
 * 	
 * 
 *     
 *     int bindingAuthorizationData = 0; 
 * }
 * </pre>
 */
class BindingAcknowledgement : public ::MobilityHeader
{
  protected:
    int status_var;
    unsigned int sequenceNumber_var;
    unsigned int lifetime_var;
    bool keyManagementFlag_var;
    int bindingAuthorizationData_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingAcknowledgement&);

  public:
    BindingAcknowledgement(const char *name=NULL, int kind=0);
    BindingAcknowledgement(const BindingAcknowledgement& other);
    virtual ~BindingAcknowledgement();
    BindingAcknowledgement& operator=(const BindingAcknowledgement& other);
    virtual BindingAcknowledgement *dup() const {return new BindingAcknowledgement(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatus() const;
    virtual void setStatus(int status_var);
    virtual unsigned int getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned int sequenceNumber_var);
    virtual unsigned int getLifetime() const;
    virtual void setLifetime(unsigned int lifetime_var);
    virtual bool getKeyManagementFlag() const;
    virtual void setKeyManagementFlag(bool keyManagementFlag_var);
    virtual int getBindingAuthorizationData() const;
    virtual void setBindingAuthorizationData(int bindingAuthorizationData_var);
};

inline void doPacking(cCommBuffer *b, BindingAcknowledgement& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingAcknowledgement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingError extends MobilityHeader
 * {
 *     int status enum(BEStatus);
 *     IPv6Address homeAddress;
 * 	
 * 
 * }
 * </pre>
 */
class BindingError : public ::MobilityHeader
{
  protected:
    int status_var;
    ::IPv6Address homeAddress_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingError&);

  public:
    BindingError(const char *name=NULL, int kind=0);
    BindingError(const BindingError& other);
    virtual ~BindingError();
    BindingError& operator=(const BindingError& other);
    virtual BindingError *dup() const {return new BindingError(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatus() const;
    virtual void setStatus(int status_var);
    virtual IPv6Address& getHomeAddress();
    virtual const IPv6Address& getHomeAddress() const {return const_cast<BindingError*>(this)->getHomeAddress();}
    virtual void setHomeAddress(const IPv6Address& homeAddress_var);
};

inline void doPacking(cCommBuffer *b, BindingError& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingError& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeTestInit extends MobilityHeader
 * {
 *     unsigned int homeInitCookie;
 * }
 * </pre>
 */
class HomeTestInit : public ::MobilityHeader
{
  protected:
    unsigned int homeInitCookie_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeTestInit&);

  public:
    HomeTestInit(const char *name=NULL, int kind=0);
    HomeTestInit(const HomeTestInit& other);
    virtual ~HomeTestInit();
    HomeTestInit& operator=(const HomeTestInit& other);
    virtual HomeTestInit *dup() const {return new HomeTestInit(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getHomeInitCookie() const;
    virtual void setHomeInitCookie(unsigned int homeInitCookie_var);
};

inline void doPacking(cCommBuffer *b, HomeTestInit& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HomeTestInit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeTest extends MobilityHeader
 * {
 *     unsigned int homeInitCookie;
 *     unsigned int homeKeyGenToken;
 * 	
 * }
 * </pre>
 */
class HomeTest : public ::MobilityHeader
{
  protected:
    unsigned int homeInitCookie_var;
    unsigned int homeKeyGenToken_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeTest&);

  public:
    HomeTest(const char *name=NULL, int kind=0);
    HomeTest(const HomeTest& other);
    virtual ~HomeTest();
    HomeTest& operator=(const HomeTest& other);
    virtual HomeTest *dup() const {return new HomeTest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getHomeInitCookie() const;
    virtual void setHomeInitCookie(unsigned int homeInitCookie_var);
    virtual unsigned int getHomeKeyGenToken() const;
    virtual void setHomeKeyGenToken(unsigned int homeKeyGenToken_var);
};

inline void doPacking(cCommBuffer *b, HomeTest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, HomeTest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet CareOfTestInit extends MobilityHeader
 * {
 *     unsigned int careOfInitCookie;
 * }
 * </pre>
 */
class CareOfTestInit : public ::MobilityHeader
{
  protected:
    unsigned int careOfInitCookie_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CareOfTestInit&);

  public:
    CareOfTestInit(const char *name=NULL, int kind=0);
    CareOfTestInit(const CareOfTestInit& other);
    virtual ~CareOfTestInit();
    CareOfTestInit& operator=(const CareOfTestInit& other);
    virtual CareOfTestInit *dup() const {return new CareOfTestInit(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getCareOfInitCookie() const;
    virtual void setCareOfInitCookie(unsigned int careOfInitCookie_var);
};

inline void doPacking(cCommBuffer *b, CareOfTestInit& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CareOfTestInit& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet CareOfTest extends MobilityHeader
 * {
 *     unsigned int careOfInitCookie;
 *     unsigned int careOfKeyGenToken;
 * 	
 * }
 * </pre>
 */
class CareOfTest : public ::MobilityHeader
{
  protected:
    unsigned int careOfInitCookie_var;
    unsigned int careOfKeyGenToken_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CareOfTest&);

  public:
    CareOfTest(const char *name=NULL, int kind=0);
    CareOfTest(const CareOfTest& other);
    virtual ~CareOfTest();
    CareOfTest& operator=(const CareOfTest& other);
    virtual CareOfTest *dup() const {return new CareOfTest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getCareOfInitCookie() const;
    virtual void setCareOfInitCookie(unsigned int careOfInitCookie_var);
    virtual unsigned int getCareOfKeyGenToken() const;
    virtual void setCareOfKeyGenToken(unsigned int careOfKeyGenToken_var);
};

inline void doPacking(cCommBuffer *b, CareOfTest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CareOfTest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet BindingRefreshRequest extends MobilityHeader
 * {
 * }
 * </pre>
 */
class BindingRefreshRequest : public ::MobilityHeader
{
  protected:

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BindingRefreshRequest&);

  public:
    BindingRefreshRequest(const char *name=NULL, int kind=0);
    BindingRefreshRequest(const BindingRefreshRequest& other);
    virtual ~BindingRefreshRequest();
    BindingRefreshRequest& operator=(const BindingRefreshRequest& other);
    virtual BindingRefreshRequest *dup() const {return new BindingRefreshRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, BindingRefreshRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BindingRefreshRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>networklayer/xmipv6/MobilityHeader.msg</tt> by opp_msgc.
 * <pre>
 * packet HomeAddressOption extends IPv6DestinationOptionsHeader
 * {
 *     @customize(true);
 *     IPv6Address homeAddress;
 * }
 * </pre>
 *
 * HomeAddressOption_Base is only useful if it gets subclassed, and HomeAddressOption is derived from it.
 * The minimum code to be written for HomeAddressOption is the following:
 *
 * <pre>
 * class HomeAddressOption : public HomeAddressOption_Base
 * {
 *   public:
 *     HomeAddressOption() : HomeAddressOption_Base() {}
 *     HomeAddressOption(const HomeAddressOption& other) : HomeAddressOption_Base() {operator=(other);}
 *     HomeAddressOption& operator=(const HomeAddressOption& other) {HomeAddressOption_Base::operator=(other); return *this;}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from HomeAddressOption_Base
 * };
 * </pre>
 */
class HomeAddressOption_Base : public ::IPv6DestinationOptionsHeader
{
  protected:
    ::IPv6Address homeAddress_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HomeAddressOption_Base&);
    // make constructors protected to avoid instantiation
    HomeAddressOption_Base();
    HomeAddressOption_Base(const HomeAddressOption_Base& other);
    // make assignment operator protected to force the user override it
    HomeAddressOption_Base& operator=(const HomeAddressOption_Base& other);

  public:
    virtual ~HomeAddressOption_Base();
    virtual HomeAddressOption_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class HomeAddressOption");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual IPv6Address& getHomeAddress();
    virtual const IPv6Address& getHomeAddress() const {return const_cast<HomeAddressOption_Base*>(this)->getHomeAddress();}
    virtual void setHomeAddress(const IPv6Address& homeAddress_var);
};


#endif // _MOBILITYHEADER_M_H_
